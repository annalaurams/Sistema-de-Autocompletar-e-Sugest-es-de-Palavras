# **Sistema de Autocompletar e Sugest√µes de Palavras**

Atividade para a disciplina de Algoritmos e Estruturas de Dados II. <br/>

## üéØObjetivo 

O projeto foi desenvolvido na linguagem de programa√ß√£o ```C++```.
<br>
O objetivo principal √© estabelecer uma rela√ß√£o entre as palavras presentes nos textos, considerando a frequ√™ncia com que ocorrem, e as palavras que os utilizadores est√£o a pesquisar.
<br>A base desse algoritmo segue o trabalho realizado anteriormente e pode ser acessado em  <a href="https://github.com/annalaurams/Top-K-Elementos.git">Top K elementos</a> sendo este continua√ß√£o do anterior.

No √¢mbito deste projeto, o objetivo consiste em desenvolver um sistema capaz de fornecer funcionalidades de autocompletar e sugest√µes de palavras aos utilizadores. Para tal, baseamo-nos na estrutura de uma √°rvore bin√°ria comum como alicerce. Al√©m disso, implementamos uma √°rvore AVL e o algoritmo de Huffman com o intuito de realizar compara√ß√µes de desempenho.
<br>

## üóÇÔ∏èEstrutura 

- Dentro da pasta ```src``` cont√©m a pasta ```include``` com os arquivos ```.hpp```:

- ```document.hpp:``` Inclus√£o de bibliotecas e defini√ß√£o da vari√°vel ```K```.
- ```shared.hpp:```  Cont√©m a struct ```WordInfo```..
- ```tree.hpp:``` Cont√©m a struct ```No```.
- ```avl.hpp:```  Cont√©m a struct ```AVL```.
- ```huffman.hpp:```  Cont√©m a struct ```Huffman```.

De fora da pasta ```include```cont√©m os arquivos ```.cpp```

- ```document.cpp:``` Desenvolvimento das fun√ß√µes de leitura e manipula√ß√£o dos arquivos de entrada.    
- ```tree.cpp:```  Fun√ß√µes relacionadas a √°rvore bin√°ria comum.
- ```avl.cpp:```  Fun√ß√µes relacionadas a √°rvore avl.  
- ```huffman.cpp:```  Fun√ß√µes relacionadas a codifica√ß√£o de huffman.  
- ```heap.cpp:```  Implementa√ß√£o do heap.  
- ```main.cpp:``` Chamada das fun√ß√µes usadas e o tempo de execu√ß√£o do programa.

- Dentro da pasta ```data```cont√©m os arquivos:

- ```input.txt:``` Palavras de busca. 
- ```stopwords.txt:``` Artigos e conjun√ß√µes como (a, o, as, os, e, ou).
- ```output.txt``` Arquivo de sa√≠da. 

- Outros arquivos contidos dentro da pasta ```data```se referem aos textos de entrada.

## üìùDecis√µes de implementa√ß√£o  

As especifica√ß√µes a seguir foram propostas para discuss√£o do problema:

 
- Os textos de entrada s√£o lidos independente do nome, desde que estejam na pasta ```data``` e os nomes s√£o armazenados em uma ```list<string>nameFiles```.
- Inicialmente o algoritmo percorre a lista com o nome dos arquivos, e para cada texto que √© aberto, os seguintes procedimentos ocorrem:

- O algoritmo realiza a leitura dele e cria uma tabela de dispers√£o (hash) intitulada ```glossary```, para contar quantas vezes cada palavra aparece no texto. A chave do hash √© a pr√≥pria palavra e o valor s√£o as ocorr√™ncias, armazenadas em uma struct denominada ```WordInfo```.

- Ap√≥s isso, outro looping inicia para a lista de palavras a serem buscadas, para cada palavra do input os seguintes procedimentos ocorrem:
  1. √â verificado se a palavra est√° no texto, se n√£o estiver ela √© ignorada e √© processado a pr√≥xima palavra.
<br>  
Se estiver, o pr√≥ximo comando ser√°:

- A partir de um tamanho K, √© criado um vetor intitulado ```heap```  que armazena as K palavras mais ocorrentes do texto.

Em seguida:

  2. √â verificado se a palavra est√° no heap, se sim, ela √© retirada dele. Se n√£o, o elemento de menor ocorr√™ncia do heap √© tirado.
  3. √â criada a √°rvore bin√°ria.
  4. √â criada a √°rvore AVL.
  5. √â criada a √°rvore a partir do c√≥digo de Huffman.

As √°rvores criadas ter√£o a mesma quantidade de elementos que o valor de ```K```e cada n√≥ √© uma posi√ß√£o do heap.

- Depois desses passos, todas as √°rvores e o heap s√£o exclu√≠dos.
- √â processada a pr√≥xima palavra, e o procedimento se repete at√© que todos os inputs sejam processados.
- Ap√≥s isso  o gloss√°rio √© limpado e √© lido o pr√≥ximo texto, repetindo os mesmos passos at√© que todos sejam lidos.
- Quando todos forem lidos, o algoritmo finaliza o output e encerra o programa.

De modo geral, para cada texto √© buscado uma lista de palavras e para cada uma presente no texto, ela ter√° 3 tipos de estruturas em √°rvore.

- Os textos de entrada s√£o lidos caracter por caracter, e utiliza-se um switch case para identificar o in√≠cio e o fim das palavras.
- As palavras que cont√©m h√≠fen, tiveram o h√≠fen removido. Por exemplo "arco-√≠ris" passa a ser "arco√≠ris".
- O valor da vari√°vel ```K```pode ser alterado, por√©m sempre deve ser um valor com uma unidade a mais do que se deseja mostrar <br>
  exemplo: Para um heap de tamanho 20, o valor de K dever√° ser 21.

- A principal fun√ß√£o do c√≥digo denominada ```search```, inclusa do arquivo ```document.cpp``` √© a respons√°vel por organizar todas as etapas mencionadas, garantindo que a ordem de chamada das fun√ß√µes e o looping mantenham o funcionamento do algoritmo.

- A sa√≠da completa do programa est√° no arquivo ```output.txt``` que ser√° criado ao longo da execu√ß√£o, nele cont√©m:<br>
- Texto analisado
- Palavra com sua frequ√™ncia naquele texto
- √Årvore bin√°ria e avl que mostram a palavra e sua ocorr√™ncia e a codifica√ß√£o de huffman que mostra a palavra e seu c√≥digo, correspondente a esse texto.
Se a palavra n√£o estiver no texto, nada sobre ela ser√° mostrado no output.
- As 3 estruturas mencionadas s√£o impressas no formato "p√≥s ordem".

## üíªMetodologia  
### √Årvore Bin√°ria Comum

Uma √°rvore bin√°ria √© uma estrutura de dados hier√°rquica composta por n√≥s, em que cada n√≥ pode ter, no m√°ximo, dois filhos: um filho √† esquerda e um filho √† direita. <br>
Cada n√≥ de uma √°rvore bin√°ria consiste em tr√™s partes:

1. Dados: Armazena as informa√ß√µes associadas ao n√≥, nessa caso uma struct ```WordInfo```com a palavra e a ocorr√™ncia.
1. Ponteiro para o filho esquerdo.
1. Ponteiro para o filho direito.

- A regra para inser√ß√£o √©: Dado um n√≥, se o valor a ser inserido for menor ou igual ao n√≥, o item ir√° para a esquerda e se for um valor maior que o n√≥ o item vai para direita. Esse processo inicia pela raiz, desde que ela exista. Se n√£o o elemento se torna a raiz.

- Neste caso, quando o valor for igual a um j√° inserido na √°rvore, esse novo ser√° inserido a esquerda do n√≥.

Custo Computacional: $O$ $(n)$
#### Exemplo da inser√ß√£o deste m√©todo 
<br>

<div style="display: flex; justify-content: center;">
    <img src="img/tree.gif" width="500" height="250">
</div>


### AVL (√Årvore Adelson-Velsky e Landis)

A √°rvore AVL √© uma √°rvore de pesquisa bin√°ria aproximadamente balanceada. <br>
A regra de inser√ß√£o √© a mesma que na bin√°ria comum, por√©m  as diferen√ßas entre as alturas das sub√°rvores esquerda e direita √© no m√°ximo 1.<br>
Esse equil√≠brio √© mantido por meio de ```rota√ß√µes```, podendo elas serem simples ou duplas. As duplas nada mais s√£o que duas simples seguidas.<br>
Sua estrutura cont√©m o dado, ponteiros para esquerda e direita assim como na estrutura anterior, com o acr√©cimo de uma v√°riavel ```fator de balanceamento ```em cada n√≥.

- Neste caso, quando o valor for igual a um j√° inserido na √°rvore, este valor ser√° inserido a esquerda do n√≥.

Para cada n√≥ √© calculado a dist√¢ncia dele at√© seu √∫ltimo n√≥ (folha) e verifica-se a diferen√ßa de altura entre as sub√°rvores.<br>
Para tal, utiliza-se o  ```fator de balanceamento```de cada n√≥.<br>
A √°rvore est√° balanceada se o fator de equil√≠brio em cada n√≥ estiver entre -1 e 1, se n√£o, ela estar√° desequilibrada e √© necess√°rio fazer o balanceamento.

Ao identificar o desbalanceamento na:

- Sub√°rvore da direita do filho da direita do n√≥, ```rota√ß√£o simples √† esquerda```.
- Sub√°rvore da esquerda do filho da direita do n√≥, ```rota√ß√£o dupla √† esquerda```.  
- Sub√°rvore da direita do filho da esquerda do n√≥, ```rota√ß√£o dupla √† direita```.
- Sub√°rvore da esquerda do filho da esquerda do n√≥, ```rota√ß√£o simples √† direita```.

Custo Computacional: $O$ $log$ $(n)$ onde $n$ √© o n√∫mero de n√≥s na √°rvore.

#### Exemplo da inser√ß√£o deste m√©todo, com rota√ß√£o dupla

|           |           |
| --------- | --------- |
| <img src="img/1.png" alt="Descri√ß√£o da imagem 1" width="500"> | <img src="img/2.png" alt="Descri√ß√£o da imagem 2" width="500"> |
Ao inserir o pr√≥ximo elemento, o ```7``` percebe-se que ficar√° desequilibrada.
| <img src="img/3.png" alt="Descri√ß√£o da imagem 3" width="500"> | <img src="img/4.png" alt="Descri√ß√£o da imagem 4" width="500"> |
| <img src="img/5.png" alt="Descri√ß√£o da imagem 5" width="500"> | <img src="img/6.png" alt="Descri√ß√£o da imagem 6" width="500"> |

Ocorreu rota√ß√£o dupla, primeiro uma simples √† esquerda e depois uma simples √† direita. <br>
O n√≥ $6$ que anteriormente era pai do $7$, se tornou filho esquerdo dele.


### Codifica√ß√£o de Huffman

O algoritmo de codifica√ß√£o de Huffman √© um m√©todo de compress√£o de dados que √© amplamente utilizado na compacta√ß√£o de informa√ß√µes. √â √∫til para compactar os dados nos quais h√° caracteres (palavras) que ocorrem com frequ√™ncia. Foi desenvolvido pela primeira vez por David Huffman.<br>
Dado o heap, a tarefa √© encontrar c√≥digos Huffman para cada palavra. Funciona da seguinte maneira:

1. Os dados s√£o organizados em ordem crescente de frequ√™ncia e armazenados em uma fila de prioridade.
2. Cria-se um n√≥ vazio ```x```. A primeira frequ√™ncia m√≠nima se torna filho esquerdo de x e a segunda frequ√™ncia m√≠nima o filho direito de x. <br>
  O valor de x ser√° a soma das duas frequ√™ncias m√≠nimas que se tornaram seus filhos.
3. Essas duas ocorr√™ncias utilizadas s√£o removidas da fila, e x √© adicionada de volta na fila, troca-se dois n√≥s por um √∫nico.
4. O processo se repete at√© que reste apenas um elemento na fila.
5. Por fim, se tem a √°rvore montada.
6. Para os n√≥s filhos a esquerda √© atribu√≠do o valor ```0```.
7. Para os n√≥s filhos a direita √© atribu√≠do o valor ```1```.

- Cada palavra ter√° um c√≥digo formado por 0 e/ou 1.
- Para decodificar o c√≥digo, deve-se percorrer a √°rvore seguindo os bits no c√≥digo at√© chegar a uma folha, que corresponde a um elemento do conjunto de dados original.

Complexidade de tempo: $O$ $($ $n*log$ $n$ $)$ onde $n$ √© o n√∫mero de caracteres √∫nicos <br>
Espa√ßo Auxiliar: $O$ $(n)$

#### Exemplo da inser√ß√£o deste m√©todo

|           |           |
| --------- | --------- |
| <img src="img/17.png" alt="Descri√ß√£o da imagem 17" width="280"> | <img src="img/18.png" alt="Descri√ß√£o da imagem 2" width="280"> |

Acima, foi somado o $1$ $+$ $3$, resultando em um novo n√≥ de valor $4$
<br>
n√≥ com frequ√™ncia $1$ se tornou filho esquerdo e o n√≥ com frequ√™ncia $3$ se tornou filho direito de $4$
<br>
$4$ foi inserido de volta na fila

| <img src="img/21.png" alt="Descri√ß√£o da imagem 5" width="280"> | <img src="img/22.png" alt="Descri√ß√£o da imagem 6" width="280"> |

O procedimento mencionado anteriormente se repete at√© restar 1 elemento na fila, neste caso o n√≥ de valor $15$.
Atribuindo os $0$ e $1$, obtem-se a √°rvore.<br>
Por exemplo, o c√≥digo da palavra "talvez" ser√° "101"


## üíªCompara√ß√£o entre algoritmos

As √°rvores de busca bin√°ria podem ser bem aplicada em algoritmos de ordena√ß√£o por exemplo, ou ainda usadas para representar uma hierarquia de forma eficiente e ainda serem uilizadas como estruturas de dados que implementam dicion√°rios (tabela hash) para manter as chaves em ordem, permitindo a busca eficiente de chaves pr√≥ximas. <br>
Por√©m, a falta de equil√≠brio √© uma desvantagem para as √°rvores bin√°rias, pois no pior caso, a altura da √°rvore pode ser $O(n)$, resultando em complexidade de tempo de $O(n)$ para as opera√ß√µes. Pois ela se torna cada vez mais profunda.
<br>
No entanto, o processo de balanceamento pode ser custoso. Na estrutura AVL, envolve a atualiza√ß√£o de ponteiros e valores em diferentes partes da √°rvore. Exigindo mais opera√ß√µes de rota√ß√£o e ajuste para cada novo n√≥ inserido ou removido.<br>
Por√©m, essas √°rvores garantem a estabilidade aproximada da estrutura, tornando-as valiosas em cen√°rios onde o equil√≠brio √© fundamental para o desempenho geral do sistema. P√≥rem para grande volume de dados, manter o custo das rota√ß√µes e de mais elementos para montar a estrutura, torna a AVL menos vi√°vel de ser utilizada.
<br>
Entretanto, a frequ√™ncia de uma determinada informa√ß√£o em um grupo de dados pode ser revelante, no caso da codifica√ß√£o de Huffman, por exemplo. Na pr√°tica, nem todos as palavras ocorrem com a mesma frequ√™ncia.<br> 
A codifica√ß√£o Huffman tira vantagem disso e atribui c√≥digos menores para strings mais frequentes, em detrimento da atribui√ß√£o de c√≥digos maiores para as menos frequentes. Torando-se uma implementa√ß√£o √∫til para Compacta√ß√£o de arquivos e Transmiss√£o de dados pela Internet, pois cada c√≥digo √© exclusivo para cada dado.
<br> 
- Se tratando de tempo de execu√ß√£o, a diferen√ßa entre os algoritmos pode ser mostrada pelo gr√°fico abaixo, que marca o tempo de constru√ß√£o da estrutura, escrita no output e exclus√£o da mesma, medido em nanossegundos.<br> 
Para este teste, foi feito a constru√ß√£o para um texto, no caso, o texto ```filosofia```, buscando 8 palavras, contidas no input disponibilizado.
<br> 
<div style="display: flex; justify-content: center;">
    <img src="img/grafico.png" width="430" height="280">
</div>

- A diferen√ßa √© significamente pequena, mas para uma grande entrada de dados, algumas especificidades da estrutura podem ser determinantes no desempenho do programa.
<br>

 ## üïúTempo de execu√ß√£o 

A contagem foi feita pelas ferramentas disponibilizadas pela bibioteca ```chrono```. <br/>
O algoritmo foi executado 10 vezes e obteve-se como m√©dia geral o tempo de: $435,4$ $ms$

## ‚úÖResultados 

Utilizando K = 20 e os arquivos disponibilizados nesse git:

Heap:

<div style="display: flex; justify-content: center;">
    <img src="img/heap.png" width="250" height="280">
</div>

Exemplo de um trecho output (n√£o cont√©m todas as K palavras na imagem):


<div style="display: flex; justify-content: center;">
    <img src="img/output.png" width="500" height="280">
</div>

No terminal √© mostrado apenas o tempo de execu√ß√£o total do programa.<br>


##  üìãConclus√£o 

Este projeto permitiu a explora√ß√£o e implementa√ß√£o de diferentes estruturas de dados e algoritmos em um contexto pr√°tico. Foi poss√≠vel observar as vantagens e desvantagens de cada uma desses algoritmos em rela√ß√£o √† tarefa de autocompletar e oferecer sugest√µes de palavras aos usu√°rios.
Em termos de tempo de execu√ß√£o, os algoritmos apresentaram desempenho variado, com a √°rvore bin√°ria comum sendo um pouco mais r√°pida do que as duas outras estruturas, neste contexto.

##  üëæCompila√ß√£o e Execu√ß√£o  

Esse pequeno exemplo possui um arquivo Makefile que realiza todo o procedimento de compila√ß√£o e execu√ß√£o. <br/>Para tanto, temos as seguintes diretrizes de execu√ß√£o:


| Comando                |  Fun√ß√£o                                                                                           |                     
| -----------------------| ------------------------------------------------------------------------------------------------- |
|  `make clean`          | Apaga a √∫ltima compila√ß√£o realizada contida na pasta build                                        |
|  `make`                | Executa a compila√ß√£o do programa utilizando o gcc, e o resultado vai para a pasta build           |
|  `make run`            | Executa o programa da pasta build ap√≥s a realiza√ß√£o da compila√ß√£o                                 |

### Contato 
<div>
 <br><p align="justify"> Anna Laura Moura Santana</p>
 <a href="https://t.me/annalaurams">
 <img align="center" src="https://img.shields.io/badge/Telegram-2CA5E0?style=for-the-badge&logo=telegram&logoColor=white"/> 
 </div>
<a style="color:black" href="mailto:nalauramoura@gmail.com?subject=[GitHub]%20Source%20Dynamic%20Lists">
‚úâÔ∏è <i>nalauramoura@gmail.com</i>
</a>
